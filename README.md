# Configuard

Configuard is a .NET CLI for validating configuration contracts across environments before deployment.

> [!WARNING]
> This project is AI-generated ("vibe-coded"). Review code, tests, and release artifacts before using in production.

Current focus: reliable `validate` behavior with contract-based rules and CI-friendly exit codes.

## 0.2.0 Highlights

- Added optional `envSnapshot` source support with provenance-aware resolution.
- Hardened source loading semantics with explicit hard-fail behavior for required inputs.
- Expanded `explain --verbosity detailed` diagnostics (matched rule mode, source order, candidate paths).
- Added CI/release automation via GitHub Actions, including NuGet publish and release artifact flow.
- Added MIT licensing and package metadata improvements.

## 0.2.2 Patch Highlights

- Hardened contract-load semantic validation for environments, per-key source preferences, and constraints shape/bounds.
- Added command-level input-error regression tests and a full valid-contract matrix validation test.
- Refactored `ContractLoader` internals into focused rule validators while preserving behavior.

## Why Configuard

- Prevent config drift between environments.
- Catch missing/forbidden keys before runtime.
- Enforce type and constraint rules from a single contract file.

## Current Status

Implemented:

- CLI command routing (`validate`, `diff`, `explain`)
- Experimental Phase 2 discovery command (`discover`, read-only JSON report)
- Contract loading (`configuard.contract.json`, version `1`)
- `validate` engine for:
  - `requiredIn`, `forbiddenIn`
  - type checks (`string`, `int`, `number`, `bool`, `object`, `array`)
  - constraints (`enum`, length, regex, numeric bounds, array bounds)
  - per-key `sourcePreference` (`appsettings` / `dotenv` / `envsnapshot`)
- Source loading from:
  - `appsettings.json` + `appsettings.{env}.json`
  - optional `.env` + `.env.{env}`
  - optional environment snapshots via `sources.envSnapshot.environmentPattern`
- Output formats for `validate`:
  - `text` (default)
  - `json`
  - `sarif`
- Unit tests for parser, loader, validator, and formatter

In progress:

- Additional source types beyond current contract-defined inputs

## Quick Start

1) Build:

```bash
dotnet build Configuard.sln
```

2) Run validation:

```bash
dotnet run --project src/Configuard.Cli -- validate --contract examples/quickstart/configuard.contract.json
```

3) Run tests:

```bash
dotnet test Configuard.sln
```

## Install as dotnet tool

Build a local tool package:

```bash
dotnet pack src/Configuard.Cli/Configuard.Cli.csproj -c Release -o artifacts
```

Install from the local package folder:

```bash
dotnet tool install --global Configuard.Cli --add-source ./artifacts
```

Then run:

```bash
configuard --help
configuard --version
```

Pre-release verification:

```bash
powershell -NoProfile -ExecutionPolicy Bypass -File .\release-check.ps1
```

## Release automation (GitHub -> NuGet)

This repository includes `.github/workflows/release.yml` to automate build/test/pack/publish.

Setup:

1. In GitHub repo settings, add secret `NUGET_API_KEY`.
2. Ensure package ID ownership on NuGet (`Configuard.Cli`).

Publish via git tag:

```bash
git tag vX.Y.Z
git push origin vX.Y.Z
```

What the workflow does:

- Builds and tests in Release mode.
- Packs the tool with version from tag (`vX.Y.Z` -> `X.Y.Z`).
- Validates that `NUGET_API_KEY` secret is configured.
- Validates tag/manual release version matches `Configuard.Cli.csproj` version.
- Pushes package to NuGet.
- Creates a GitHub Release with autogenerated notes and uploads the `.nupkg`.

Manual publish trigger:

- Use **Actions -> Release -> Run workflow** and provide `version` (for example `X.Y.Z`).

## Continuous integration

This repository includes `.github/workflows/ci.yml`:

- triggers on pushes to `main` and on pull requests
- restores, builds, and tests the solution in Release mode
- acts as a gate before release tagging

## Command Use Cases

### `validate`

Use case: block deployments when contract rules are violated.

```bash
dotnet run --project src/Configuard.Cli -- validate --contract examples/quickstart/configuard.contract.json --env staging --env production
```

Use case: feed machine-readable output into CI tooling.

```bash
dotnet run --project src/Configuard.Cli -- validate --contract examples/quickstart/configuard.contract.json --format json
```

Use case: get compact output in pipelines while keeping exit semantics.

```bash
dotnet run --project src/Configuard.Cli -- validate --contract examples/quickstart/configuard.contract.json --verbosity quiet
```

Exit codes:

- `0`: pass
- `2`: input/contract error
- `3`: policy violations
- `4`: internal error

Warning behavior:

- Warning output fields are supported in text/json/sarif responses.
- Warnings do **not** fail the command by themselves.
- Non-zero exit code is driven by violations/errors, not warnings alone.
- Invalid `sourcePreference` values are enforced at contract-load time and return input error exit code `2` (not runtime warnings).
- Source loading failures (for example malformed JSON or missing non-optional source files) return input error exit code `2`.
- Missing `appsettings.base` source file is treated as a hard input error.

Verbosity levels (all commands):

- `quiet`: suppress command output, keep exit codes
- `normal`: default output
- `detailed`: include extra aggregate details for text output

### `diff`

Use case: detect contract-scoped drift between two environments before deployment.

```bash
dotnet run --project src/Configuard.Cli -- diff --contract examples/quickstart/configuard.contract.json --env staging --env production
```

Use case: emit machine-readable drift details.

```bash
dotnet run --project src/Configuard.Cli -- diff --contract examples/quickstart/configuard.contract.json --env staging --env production --format json
```

### `explain`

Use case: explain how one key resolves and why it passes/fails policy checks.

```bash
dotnet run --project src/Configuard.Cli -- explain --contract examples/quickstart/configuard.contract.json --env production --key ConnectionStrings:Default
```

Use case: inspect the same explanation in structured JSON.

```bash
dotnet run --project src/Configuard.Cli -- explain --contract examples/quickstart/configuard.contract.json --env production --key ConnectionStrings:Default --format json
```

### `discover` (phase 2, experimental)

Use case: statically discover configuration key paths from C# code usage patterns.

```bash
dotnet run --project src/Configuard.Cli -- discover --path . --format json --output discover-report.json
```

Safe apply mode (high-confidence additions only, no deletions):

```bash
dotnet run --project src/Configuard.Cli -- discover --path . --contract configuard.contract.json --apply
```

Scope control:

```bash
dotnet run --project src/Configuard.Cli -- discover --path . --include "src/**" --exclude "**/obj/**" --exclude "**/bin/**" --output discover-report.json
```

`--include` / `--exclude` use simple glob-style patterns against scan-relative file paths.
`--apply` appends only high-confidence discovered keys that do not already match an existing key path or alias.

Currently detected pattern examples:

- `configuration["A:B"]`
- `configuration.GetValue<T>("A:B")`
- `configuration.GetSection("A:B")`
- `services.Configure<T>(configuration.GetSection("A:B"))`
- `configuration.Bind("A:B", target)`
- `services.AddOptions<T>().Bind(configuration.GetSection("A:B"))`

Discovery confidence:

- `high`: fully literal path discovery.
- `medium`: partially composed expression with unresolved dynamic segments (annotated with notes in report).

Deterministic report behavior:

- Findings and evidence are emitted in stable sorted order for repeatable output.
- `generatedAtUtc` is sourced via an internal clock provider seam to support deterministic tests.

## Contract File

Default contract path: `configuard.contract.json`

Reference docs:

- `docs/configuard/02-contract-format.md`
- `docs/configuard/03-cli-ux.md`
- `docs/configuard/04-mvp-boundaries.md`

## Project Structure

```text
docs/configuard/
  01-competitor-matrix.md
  02-contract-format.md
  03-cli-ux.md
  04-mvp-boundaries.md
  05-phase2-roslyn.md
  implementation-notes.md

src/Configuard.Cli/
  Cli/
  Validation/

tests/Configuard.Cli.Tests/

examples/quickstart/
  configuard.contract.json
  appsettings.json
  appsettings.production.json
```

## License

MIT - see `LICENSE`.
